#!/bin/bash
#===============================================================================
#
#  USAGE: 
#  REQUIREMENTS:
#
#===============================================================================

red="\e[0;31m"
green="\e[0;32m"
yellow="\e[0;33m"
TOA="\e[0m" # No Color

# START functions ##############################################################

function logInfo () {
    echo -e "${green}$1${TOA}"
}

function logWarn () {
  echo -e "${yellow}$1${TOA}"
}

function logError () {
  echo -e "${red}$1${TOA}" 1>&2
}

function getPattern () {
  pattern_case="$1"
  #   echo "$pattern_case"
  retValue=$(sed '/^#/d' "$pattern_case" | grep 'pattern=' | gawk  -F 'pattern=' '{print $2}')
  
  # retValue
  echo "$retValue"
}

function getResults () {
  pattern_case="$1"
  txt_path="$2"
  pattern=$(getPattern "$pattern_case")
#echo "$pattern_case"
  echo "$pattern" | { while read -r line; do
    # line=$(echo "$line" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g')
    # sed "s/$line/\2/" "$txt_path"
    # echo "$line"
    pattern_delete=$(sed '/^#/d' "$pattern_case" | grep 'pattern_delete=' | gawk  -F 'pattern_delete=' '{print $2}')
    if [ -z "$pattern_delete" ]; then
      result=$(grep -oaE "$line" "$txt_path" |                                 sed -e 's/^ *//' | sed -e 's/ *$//')
    else
      pattern_delete=$(echo "$pattern_delete" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
      result=$(grep -oaE "$line" "$txt_path" | sed -e "s/$pattern_delete//g" | sed -e 's/^ *//' | sed -e 's/ *$//')
    fi
    if [ "$result" != "" ]; then
      echo "$result"
  #    exit 0
    fi
  done }
}

function runTest () {
  pattern_case="$1"
  pattern_path=$(dirname "$pattern_case")
  test_path=${pattern_path//pattern/tests}
  pattern_name=$(basename "$pattern_case")

  test_name=${pattern_name//pattern/}
  # Finde Einträge in "tests/test-....positive.....list" "tests/test-....negative.....list" und  ohne führende und abschließende Leerzeichen
  find "$test_path" -type f -name "$test_name*.list" | sort | { while read -r file;
  do
     matched_elements=$(grep '^[^ #]' "$file")
     if [ "$matched_elements" != "" ]; then
       logError "$matched_elements"
       logError "Entry without leading spaces found: $file"
       exit 1
     fi
     
     matched_elements=$(grep '^[^ #].*[^ ]$' "$file")
     if [ "$matched_elements" != "" ]; then
       logError "$matched_elements"
       logError "Entry without trailing spaces found: $file"
       exit 1
     fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  # positive tests
  test_name_positive=${pattern_name//pattern/positive}
  find "$test_path" -type f -name "$test_name_positive*.list" | sort | { while read -r test_case_positive;
    do
      test_results=$(getResults "$pattern_case" "$test_case_positive")
      matched_elements=$(echo "$test_results" | sed '/^$/d' | wc -l)
      given_elements=$(sed '/^pattern=/d' "$test_case_positive" | sed '/^$/d' | sed '/^#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_positive")"
      echo "$test_results"
      if test "$matched_elements" -lt "$given_elements"; then
        logError "Test failed, to few elements found: $matched_elements/$given_elements"
        exit 1
      elif test "$matched_elements" -gt "$given_elements"; then
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      else
        logInfo "Test OK: $matched_elements/$given_elements"
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  
  # negative tests
  test_name_negative=${pattern_name//pattern/negative}
  find "$test_path" -type f -name "$test_name_negative*.list" | sort | { while read -r test_case_negative;
    do
      test_results=$(getResults "$pattern_case" "$test_case_negative")
      matched_elements=$(echo "$test_results" | sed '/^$/d' | wc -l)
      given_elements=$(sed '/^pattern=/d' "$test_case_negative"| sed '/^$/d' | sed '/^#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_negative")"
      echo "$test_results"
      if test "$matched_elements" -eq "0"; then
        logInfo "Test OK: $matched_elements/$given_elements"
      else
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi
}

function runSearch () {
  pattern_case="$1"
  pdf_path="$2"
  
  pdf_dirname=$(dirname "$pdf_path")
  # echo "$pdf_dirname"
  pdf_filename=$(basename "$pdf_path")
  pdf_filename="${pdf_filename%.*}"
  lines=$(wc -l < "$pdf_dirname/$pdf_filename.txt")
  if [ "$lines" != "0" ]
  then
    getResults "$pattern_case" "$pdf_dirname/$pdf_filename.txt"
  fi

}

# createTxtFile "$pdf_path" "$pdf_dirname" "$pdf_filename"
function createTxtFile () {
  pdf_path="$1"
  pdf_dirname="$2"
  pdf_filename="$3"
  
  make_space=$(python -c 'print u"\u0001\u000C\u0009\u00A0\u2004\u2005\u2006\u2009\u200A\u200B".encode("utf8")')
  
  pdftotext -q "$pdf_path" "$pdf_dirname/$pdf_filename.txt"
  
  # Remove all NewLines (sed) and add a line terminator (awk) and write to a temporary file
  temp_file=$(tempfile)
  
  ####################################
  # nicht entfernen, weil
  # tr '-' ' ' --> NOK --> VES-M Halle
  # '/' -> ' / ' --> NOK --> V 3/6
  # '-' -> ' - ' --> NOK --> VES-M Halle
  #  | sed -e "s/[[:space:]]\{2,\}/ /g"
  ####################################
  sed ':a;N;$!ba;s/\n/ \| /g' "$pdf_dirname/$pdf_filename.txt" | awk '{printf("%s!\n",$0)}' | sed 's/['"$make_space"']/ /g' | sed -e 's/\.[[:space:]]/ \. /g' | sed -e 's/\,[[:space:]]/ \, /g' | sed -e 's/(/ ( /g' | sed -e 's/)/ ) /g' | sed -e 's/\:[[:space:]]/ \: /g' | sed -e 's/\;[[:space:]]/ \; /g' > "$temp_file"
  # Move the temporary file 
  mv "$temp_file" "$pdf_dirname/$pdf_filename.txt"
}

# END functions ################################################################

pattern_path="$2"
pdf_path="$3"

if [ ! -d "$pattern_path" ] && [ ! -d "$(dirname "$pattern_path")" ]; then
  logError "Kein Verzeichnis mit Regulären Ausdrücken gefunden ($pattern_path)"
  exit 1
fi

if [ "$1" == "test" ]; then
  if [ -f "$pattern_path" ]; then
    runTest "$pattern_path"
  else
    find "$pattern_path" -type f -name '*.pattern' | { while read -r pattern_case;
      do
        runTest "$pattern_case"
    done }
  fi
elif [ "$1" == "run" ]; then
  if [ ! -f "$pdf_path" ]; then
    logError "PDF not found \"$3\""
    exit 1
  else
    pdf_dirname=$(dirname "$pdf_path")
    # echo "$pdf_dirname"
    pdf_filename=$(basename "$pdf_path")
    pdf_filename="${pdf_filename%.*}"
    if [ -f "$pdf_dirname/$pdf_filename.md5" ]; then
      md5_current=$(cat "$pdf_dirname/$pdf_filename.md5")
    fi
    # echo "$md5_current"
    md5_new=$(md5sum "$pdf_path"  | gawk  -F ' ' '{print $1}')
    # echo "$md5_new"
    if [ "$md5_current" == "$md5_new" ]; then
      # Do nothing
      a=$a
      # logInfo "\"$(basename "$pdf_path")\" scheint sich seit dem letzten Durchlauf nicht geändert zu haben."
      # logInfo "Versuche bestehende \"$pdf_filename.txt\" zu verwenden."
    else
      # logInfo "Schreibe \"$pdf_filename.txt\"."
      createTxtFile "$pdf_path" "$pdf_dirname" "$pdf_filename"
      
      # logInfo "Schreibe \"$pdf_filename.md5\"."
      echo "$md5_new" > "$pdf_dirname/$pdf_filename.md5"
    fi
    if [ ! -f "$pdf_dirname/$pdf_filename.txt" ]; then
      # logWarn "\"$pdf_filename.txt\" nicht gefunden. schreibe \"$pdf_filename.txt\" neu."
      createTxtFile "$pdf_path" "$pdf_dirname" "$pdf_filename"
    fi

    if [ -f "$pattern_path" ]; then
      runSearch "$pattern_path" "$pdf_path"
    else
      find "$pattern_path" -type f -name 'test-*.pattern' | { while read -r pattern_case;
        do
          runSearch "$pattern_case" "$pdf_path"
      done }
    fi
  fi
fi

exit 0
