#!/bin/bash
#===============================================================================
#
#  USAGE: 
#  REQUIREMENTS:
#
#===============================================================================

red="\e[0;31m"
green="\e[0;32m"
yellow="\e[0;33m"
TOA="\e[0m" # No Color

# Absolute path to this script, e.g. /home/user/bin/foo.sh
script=$(readlink -f "$0")
# Absolute path this script is in, thus /home/user/bin
script_path=$(dirname "$script")

# START functions ##############################################################

function logInfo () {
    echo -e "${green}$1${TOA}" 1>&2
}

function logWarn () {
  echo -e "${yellow}$1${TOA}" 1>&2
}

function logError () {
  echo -e "${red}$1${TOA}" 1>&2
}

function getPattern () {
  pattern_case="$1"
  #   echo "$pattern_case"
  retValue=$(sed '/^#/d' "$pattern_case" | grep 'pattern=' | gawk  -F 'pattern=' '{print $2}')
  
  # retValue
  echo "$retValue"
}

function getResults () {
  pattern_case="$1"
  txt_path="$2"
  
  pattern=$(getPattern "$pattern_case")
  
  # prefix=$(sed '/^#/d' "$pattern_case" | grep 'prefix=' | gawk  -F 'prefix=' '{print $2}') 
  # if [ ! -z "$prefix" ]; then
  #   prefix=$(echo "$prefix" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
  # fi

  pattern_delete=$(sed '/^#/d' "$pattern_case" | grep 'pattern_delete=' | gawk  -F 'pattern_delete=' '{print $2}')    
  if [ ! -z "$pattern_delete" ]; then
    pattern_delete=$(echo "$pattern_delete" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
  fi
  
  # logInfo "pattern $pattern_case"
  # timea=$(($(date +%s%N)/1000000))

#echo "$pattern_case"
  echo "$pattern" | { while read -r line; do
    # line=$(echo "$line" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g')
    # sed "s/$line/\2/" "$txt_path"
    # echo "$line"
    
    result=$(grep -oaE "$line" "$txt_path" | sed -e 's/^ *//' | sed -e 's/ *$//')
    
    if [ ! -z "$pattern_delete" ]; then
      result=$(echo "$result" | sed -e "s/$pattern_delete//g")
    fi
    
    if [ ! -z "$prefix" ]; then
      result=$(echo "$result" | sed -E "s/^(.*)$/$prefix\1/g")
    fi

    if [ "$result" != "" ]; then
      echo "$result"
    fi
  done }
  # timeb=$(($(date +%s%N)/1000000))
  # logInfo "---> $((timeb - timea)) ms"
}

function runTest () {
  pattern_case="$1"
  pattern_path=$(dirname "$pattern_case")
  test_path=${pattern_path//pattern/tests}
  pattern_name=$(basename "$pattern_case")

  test_name=${pattern_name//pattern/}
  # Finde Einträge in "tests/test-....positive.....list" "tests/test-....negative.....list" und  ohne führende und abschließende Leerzeichen
  find "$test_path" -type f -name "$test_name*.list" | sort | { while read -r file;
  do
     matched_elements_without_leading=$(sed /^[[:space:]]*#/d "$file" | grep '^[^ ]')
     if [ "$matched_elements_without_leading" != "" ]; then
       logError "$matched_elements_without_leading"
       logError "Entry without leading spaces found: $file"
       exit 1
     fi
     
     matched_elements_without_trailing=$(sed /^[[:space:]]*#/d "$file" | grep '[^ ]$')
     if [ "$matched_elements_without_trailing" != "" ]; then
       logError "$matched_elements_without_trailing"
       logError "Entry without trailing spaces found: $file"
       exit 1
     fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  # positive tests
  test_name_positive=${pattern_name//pattern/positive}
  logInfo "$test_name_positive"
  find "$test_path" -type f -name "$test_name_positive*.list" | sort | { while read -r test_case_positive;
    do
      test_results=$(getResults "$pattern_case" "$test_case_positive")
      matched_elements=$(echo "$test_results" | sed '/^[[:space:]]*$/d' | wc -l)
      given_elements=$(sed '/^[[:space:]]*$/d' "$test_case_positive" | sed '/^[[:space:]]*#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_positive")"
      echo "$test_results"
      if test "$matched_elements" -lt "$given_elements"; then
        logError "Test failed, to few elements found: $matched_elements/$given_elements"
        exit 1
      elif test "$matched_elements" -gt "$given_elements"; then
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      else
        logInfo "Test OK: $matched_elements/$given_elements"
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  
  # negative tests
  test_name_negative=${pattern_name//pattern/negative}
  find "$test_path" -type f -name "$test_name_negative*.list" | sort | { while read -r test_case_negative;
    do
      test_results=$(getResults "$pattern_case" "$test_case_negative")
      matched_elements=$(echo "$test_results" | sed '/^$/d' | wc -l)
      given_elements=$(sed '/^pattern=/d' "$test_case_negative"| sed '/^$/d' | sed '/^#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_negative")"
      echo "$test_results"
      if test "$matched_elements" -eq "0"; then
        logInfo "Test OK: $matched_elements/$given_elements"
      else
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi
}

function runSearch () {
  pattern_case="$1"
  pdf_path="$2"
  
  pdf_dirname=$(dirname "$pdf_path")
  # echo "$pdf_dirname"
  pdf_filename=$(basename "$pdf_path")
  pdf_filename="${pdf_filename%.*}"
  
  if [ -f "$pdf_dirname/$pdf_filename.txt" ]; then
    lines=$(wc -l < "$pdf_dirname/$pdf_filename.txt")
    
    if [ "$lines" != "0" ]
    then
      getResults "$pattern_case" "$pdf_dirname/$pdf_filename.txt"
    fi
  fi
}

function echoerr() { echo "$@" 1>&2; }

# END functions ################################################################



pattern_path="$2"
pdf_path="$3"

if [ ! -d "$pattern_path" ] && [ ! -d "$(dirname "$pattern_path")" ]; then
  logError "Kein Verzeichnis mit Regulären Ausdrücken gefunden ($pattern_path)"
  exit 1
fi

if [ "$1" == "test" ]; then
  "$script_path/tools/compress_pattern"
  time_complete_a=$(($(date +%s%N)/1000000))
  if [ -f "$pattern_path" ]; then
    runTest "$pattern_path"
  else
    find "$pattern_path" -type f -name '*.pattern' | { while read -r pattern_case;
      do
        echoerr "$pattern_case"
        timea=$(($(date +%s%N)/1000000))
        
        runTest "$pattern_case"
        
        timeb=$(($(date +%s%N)/1000000))
        echoerr "---> $((timeb - timea)) ms"
    done }
  fi
  time_complete_b=$(($(date +%s%N)/1000000))
  echoerr "Gesamtzeit: $((time_complete_b - time_complete_a)) ms"
elif [ "$1" == "run" ] || [ "$1" == "create_txt" ]; then
  if [ ! -f "$pdf_path" ]; then
    logError "PDF not found \"$3\""
    exit 1
  else

    pdf_dirname=$(dirname "$pdf_path")
    pdf_filename=$(basename "$pdf_path")
    pdf_filename="${pdf_filename%.*}"
    
    md5_new_CreateTxtFile=$(md5sum "$script_path/functions/createTxtFile"  | gawk  -F ' ' '{print $1}')
    if [ -f "$pdf_dirname/createTxtFile.md5" ]; then
      md5_current_CreateTxtFile=$(cat "$pdf_dirname/createTxtFile.md5")
    else
      # Wenn Prüfsummendatei nicht existiert, dann anlegen
      logInfo "Erstelle initial \"$pdf_dirname/createTxtFile.md5\""
      echo "$md5_new_CreateTxtFile" > "$pdf_dirname/createTxtFile.md5"
    fi
    
    # echo "$md5_new"
    if [ "$md5_current_CreateTxtFile" == "$md5_new_CreateTxtFile" ]; then
      # Do nothing
      true
    else
      logInfo "Algorithmus in \"$script_path/functions/createTxtFile\" hat sich geändert. Schreibe \"$pdf_filename.txt\" neu."
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"
      logInfo "Schreibe \"createTxtFile.md5\"."
      echo "$md5_new_CreateTxtFile" > "$pdf_dirname/createTxtFile.md5"
      

    fi

    if [ -f "$pdf_dirname/$pdf_filename.md5" ]; then
      md5_current_Pdf=$(cat "$pdf_dirname/$pdf_filename.md5")
    fi
    # echo "$md5_current_Pdf"
    md5_new_Pdf=$(md5sum "$pdf_path"  | gawk  -F ' ' '{print $1}')
    # echo "$md5_new_Pdf"
    if [ "$md5_current_Pdf" == "$md5_new_Pdf" ]; then
      # Do nothing
      true
      logInfo "\"$(basename "$pdf_path")\" scheint sich seit dem letzten Durchlauf nicht geändert zu haben."
      logInfo "Versuche bestehende \"$pdf_filename.txt\" zu verwenden."
    else
      logInfo "\"$(basename "$pdf_path")\" hat sich seit dem letzten Durchlauf geändert."
      logInfo "Schreibe \"$pdf_dirname/$pdf_filename.human-readable.txt\" neu."
      if [ -f "$pdf_dirname/$pdf_filename.human-readable.txt" ]; then
        rm "$pdf_dirname/$pdf_filename.human-readable.txt"
      fi
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"
      
       logInfo "Schreibe \"$pdf_filename.md5\"."
      echo "$md5_new_Pdf" > "$pdf_dirname/$pdf_filename.md5"
    fi
    
    if [ ! -f "$pdf_dirname/$pdf_filename.txt" ]; then
       logInfo "\"$pdf_filename.txt\" nicht gefunden. schreibe \"$pdf_filename.txt\" neu."
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"
    fi

    if  [ "$1" == "run" ]; then
      # time_complete_a=$(($(date +%s%N)/1000000))
      if [ -f "$pattern_path" ]; then
        runSearch "$pattern_path" "$pdf_path"
      else
        find "$pattern_path" -type f -name 'test-*.pattern' | { while read -r pattern_case;
          do
            runSearch "$pattern_case" "$pdf_path"
        done }
      fi
      # time_complete_b=$(($(date +%s%N)/1000000))
      # logInfo "Gesamtzeit: $((time_complete_b - time_complete_a)) ms"
    fi
  fi
fi

exit 0
