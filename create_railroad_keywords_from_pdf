#!/bin/bash
#===============================================================================
#
#  USAGE:
#  REQUIREMENTS:
#
#===============================================================================

red="\e[0;31m"
green="\e[0;32m"
yellow="\e[0;33m"
TOA="\e[0m" # No Color

# Absolute path to this script, e.g. /home/user/bin/foo.sh
script=$(readlink -f "$0")
# Absolute path this script is in, thus /home/user/bin
script_path=$(dirname "$script")

cfg_category_separator=$(look category_separator "$script_path"/main.cfg | cut -d '=' -f 2-)

# START functions ##############################################################

function logInfo () {
    echo -e "${green}$1${TOA}" 1>&2
}

function logWarn () {
  echo -e "${yellow}$1${TOA}" 1>&2
}

function logError () {
  echo -e "${red}$1${TOA}" 1>&2
}

function getPattern () {
  pattern_case="$1"
  #   echo "$pattern_case"
  retValue=$(sed '/^#/d' "$pattern_case" | grep 'pattern=' | gawk  -F 'pattern=' '{print $2}')

  # retValue
  echo "$retValue"
}

function getResults () {
  pattern_case="$1"
  txt_path="$2"
  isTest="$3"

  pattern=$(getPattern "$pattern_case")
  # prefix=$(sed '/^#/d' "$pattern_case" | grep 'prefix=' | gawk  -F 'prefix=' '{print $2}')
  # if [ ! -z "$prefix" ]; then
  #   prefix=$(echo "$prefix" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
  # fi

  pattern_delete=$(sed '/^#/d' "$pattern_case" | grep 'pattern_delete=' | gawk  -F 'pattern_delete=' '{print $2}')
  if [ ! -z "$pattern_delete" ]; then
    pattern_delete=$(echo "$pattern_delete" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
  fi

  # logInfo "pattern $pattern_case"
  # timea=$(($(date +%s%N)/1000000))

#echo "$pattern_case"
  echo "$pattern" | { while read -r line; do
    # line=$(echo "$line" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g')
    # sed "s/$line/\2/" "$txt_path"
    # echo "$line"

    result=$(grep -oaE "$line" "$txt_path" | sed -e 's/^ *//' | sed -e 's/ *$//')

    if [ ! -z "$pattern_delete" ]; then
      result=$(sed -e "s/$pattern_delete//g" <<< "$result")
    fi

    if [ ! -z "$prefix" ]; then
      result=$(echo "$result" | sed -E "s/^(.*)\$/$prefix\1/g")
    fi

    if [ "$result" != "" ]; then
      category=$(look category "$pattern_case" | cut -d '=' -f 2-)
      if [ "$isTest" == "0" ]; then
        log_result=$(sort <<< "$result" | uniq | sed -e 's/^/\\t/g')
        
        logInfo "Kategorie: $category (\"$pattern_case\")\n$log_result"
        # logInfo "Treffer gefunden durch \"$pattern_case\":\n$log_result"
      fi
      while read -r keyword; do
        if [[ $keyword != "" ]]; then
          if [[ $cfg_category_separator == "" ]] || [[ $category == "" ]]; then
            echo "$keyword"
          else
            echo "$category$cfg_category_separator$keyword"
          fi
        fi
      done <<< "$result"
    fi
  done }
  # timeb=$(($(date +%s%N)/1000000))
  # logInfo "---> $((timeb - timea)) ms"
}

function runTest () {
  pattern_case="$1"
  pattern_path=$(dirname "$pattern_case")
  test_path=${pattern_path//pattern/tests}
  pattern_name=$(basename "$pattern_case")

  test_name=${pattern_name//pattern/}
  # Finde Einträge in "tests/test-....positive.....list" "tests/test-....negative.....list" und  ohne führende und abschließende Leerzeichen
  find "$test_path" -type f -name "$test_name*.list" | sort | { while read -r file;
  do
     matched_elements_without_leading=$(sed /^[[:space:]]*#/d "$file" | grep '^[^ ]')
     if [ "$matched_elements_without_leading" != "" ]; then
       logError "$matched_elements_without_leading"
       logError "Entry without leading spaces found: $file"
       exit 1
     fi

     matched_elements_without_trailing=$(sed /^[[:space:]]*#/d "$file" | grep '[^ ]$')
     if [ "$matched_elements_without_trailing" != "" ]; then
       logError "$matched_elements_without_trailing"
       logError "Entry without trailing spaces found: $file"
       exit 1
     fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  logInfo "-----"

  # positive tests
  test_name_positive=${pattern_name//pattern/positive}
  logInfo "$test_name_positive"
  
  find "$test_path" -type f -name "$test_name_positive*.list" | sort | { while read -r test_case_positive;
    do
      test_results=$(getResults "$pattern_case" "$test_case_positive" "1")
      # matched_elements=$(echo "$test_results" | sed '/^[[:space:]]*$/d' | wc -l)
      # given_elements=$(sed '/^[[:space:]]*$/d' "$test_case_positive" | sed '/^[[:space:]]*#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_positive")"
      category=$(look category "$pattern_case" | cut -d '=' -f 2-)
      test_results="${test_results//$category./}"
      
      temp_file_1="$script_path/test_results/$(basename "$test_case_positive").1"
      temp_file_2="$script_path/test_results/$(basename "$test_case_positive").2"
      
      echo "$test_results" > "$temp_file_1"
      echo -e "${yellow}$test_results${TOA}"
      
      sed '/^[[:space:]]*$/d' "$test_case_positive" | sed '/^[[:space:]]*#/d' | sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g' > "$temp_file_2"
      
      diff -arq "$temp_file_1" "$temp_file_2"  >/dev/null 2>&1; if [ $? -gt 0 ]; then logError "Test failed."; exit 1; else logInfo "Test OK"; fi
  done }
  
  if [ $? -gt 0 ]; then exit 1; fi

  logInfo "-----"


  # negative tests
  test_name_negative=${pattern_name//pattern/negative}
  logInfo "$test_name_negative"
  find "$test_path" -type f -name "$test_name_negative*.list" | sort | { while read -r test_case_negative;
    do
      test_results=$(getResults "$pattern_case" "$test_case_negative" "1")
      matched_elements=$(echo "$test_results" | sed '/^$/d' | wc -l)
      given_elements=$(sed '/^pattern=/d' "$test_case_negative"| sed '/^$/d' | sed '/^#/d' | wc -l)
      logInfo "TestCase: $(basename "$test_case_negative")"
      category=$(look category "$pattern_case" | cut -d '=' -f 2-)
      echo "${test_results//$category./}"
      if test "$matched_elements" -eq "0"; then
        logInfo "Test OK: $matched_elements/$given_elements"
      else
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi

  logInfo "-----"

  # diff tests
  diff_name=${pattern_name//\.pattern/}
  diff_name=${diff_name//test-/}

  find "$script_path/diffs" -type f -name "$diff_name.*.diff" | sort | { while read -r diff;
    do
      logInfo "$diff"
      test_results=$(getResults "$pattern_case" "$diff" "1")
      matched_elements=$(echo "$test_results" | sed '/^$/d' | wc -l)
      given_elements=$(sed '/^pattern=/d' "$diff"| sed '/^$/d' | sed '/^#/d' | wc -l)
      logInfo "TestCase: $(basename "$diff")"
      category=$(look category "$pattern_case" | cut -d '=' -f 2-)
      echo "${test_results//$category./}"
      if test "$matched_elements" -eq "0"; then
        logInfo "Test OK: $matched_elements/$given_elements"
      else
        logError "Test failed, to many elements found: $matched_elements/$given_elements"
        exit 1
      fi
  done }
  if [ $? -gt 0 ]; then exit 1; fi
}

function runSearch () {
  pattern_case="$1"
  pdf_path="$2"

  pdf_dirname=$(dirname "$pdf_path")
  # echo "$pdf_dirname"
  pdf_filename=$(basename "$pdf_path")
  pdf_filename="${pdf_filename%.*}"

  if [ -f "$pdf_dirname/$pdf_filename.txt" ]; then
    lines=$(wc -l < "$pdf_dirname/$pdf_filename.txt")

    if [ "$lines" != "0" ]
    then
      getResults "$pattern_case" "$pdf_dirname/$pdf_filename.txt" "0"
    fi
  fi
}

function echoerr() { echo "$@" 1>&2; }

# END functions ################################################################



pattern_path="$2"
pdf_path="$3"

if [ ! -d "$pattern_path" ] && [ ! -d "$(dirname "$pattern_path")" ]; then
  logError "Kein Verzeichnis mit Regulären Ausdrücken gefunden ($pattern_path)"
  exit 1
fi

if [ "$1" == "test" ]; then
  
  "$script_path/tools/compress_pattern" "$2"
  "$script_path/tools/create_diffs" "$2"
  
  if [[ ! -f $2 ]]; then
    rm "$script_path/test_results/"*.list.[12]
  fi
  
  time_complete_a=$(($(date +%s%N)/1000000))
  if [ -f "$pattern_path" ]; then
    runTest "$pattern_path"
  else
    find "$pattern_path" -type f -name '*.pattern' | { while read -r pattern_case;
      do
        echoerr "$pattern_case"
        timea=$(($(date +%s%N)/1000000))

        runTest "$pattern_case"

        timeb=$(($(date +%s%N)/1000000))
        echoerr "---> $((timeb - timea)) ms"
    done }
  fi
  time_complete_b=$(($(date +%s%N)/1000000))
  echoerr "Gesamtzeit: $((time_complete_b - time_complete_a)) ms"
elif [ "$1" == "run" ] || [ "$1" == "create_txt" ]; then
  if [ ! -f "$pdf_path" ]; then
    logError "PDF not found \"$3\""
    exit 1
  else

    pdf_dirname=$(dirname "$pdf_path")
    pdf_filename=$(basename "$pdf_path")
    pdf_filename="${pdf_filename%.*}"

    md5_new_CreateTxtFile=$(md5sum "$script_path/functions/createTxtFile"  | gawk  -F ' ' '{print $1}')

    if [ ! -f "$pdf_dirname/$pdf_filename.txt" ]; then
       logInfo "\"$pdf_filename.txt\" nicht gefunden. schreibe \"$pdf_filename.txt\" neu."
       echo "$md5_new_CreateTxtFile" > "$pdf_dirname/createTxtFile.md5"
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"
    fi


    if [ -f "$pdf_dirname/createTxtFile.md5" ]; then
      md5_current_CreateTxtFile=$(cat "$pdf_dirname/createTxtFile.md5")
    else
      # Wenn Prüfsummendatei nicht existiert, dann anlegen
      logInfo "Erstelle initial \"$pdf_dirname/createTxtFile.md5\""
      echo "$md5_new_CreateTxtFile" > "$pdf_dirname/createTxtFile.md5"
    fi

    # echo "$md5_new"
    if [ "$md5_current_CreateTxtFile" == "$md5_new_CreateTxtFile" ]; then
      # Do nothing
      true
    else
      logInfo "Algorithmus in \"$script_path/functions/createTxtFile\" hat sich geändert. Schreibe \"$pdf_filename.txt\" neu."
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"
      logInfo "Schreibe \"createTxtFile.md5\"."
      echo "$md5_new_CreateTxtFile" > "$pdf_dirname/createTxtFile.md5"
    fi

    if [ -f "$pdf_dirname/$pdf_filename.md5" ]; then
      md5_current_Pdf=$(cat "$pdf_dirname/$pdf_filename.md5")
    fi
    # echo "$md5_current_Pdf"
    md5_new_Pdf=$(md5sum "$pdf_path"  | gawk  -F ' ' '{print $1}')
    # echo "$md5_new_Pdf"
    if [ "$md5_current_Pdf" == "$md5_new_Pdf" ] && [ ! -f "$pdf_dirname/txt_created_by_pdftotext" ]; then
      logInfo "\"$(basename "$pdf_path")\" scheint sich seit dem letzten Durchlauf nicht geändert zu haben."
      logInfo "Versuche bestehende \"$pdf_filename.txt\" zu verwenden."
    else
      if [ "$md5_current_Pdf" != "$md5_new_Pdf" ]; then
        logInfo "\"$(basename "$pdf_path")\" hat sich seit dem letzten Durchlauf geändert."
      fi
      if [ -f "$pdf_dirname/txt_created_by_pdftotext" ]; then
        logWarn "\"pdftotext\" wurde zur Erstellung von \"$pdf_dirname/$pdf_filename.human-readable.txt\" verwendet. Erzwinge neue Erstellung."
      fi
      logInfo "Schreibe \"$pdf_dirname/$pdf_filename.human-readable.txt\" neu."
      if [ -f "$pdf_dirname/$pdf_filename.human-readable.txt" ]; then
        rm "$pdf_dirname/$pdf_filename.human-readable.txt"
      fi
      "$script_path/functions/createTxtFile" "$pdf_path" "$pdf_dirname" "$pdf_filename"

      # Wenn Text durch Alternativprogramm generiert wurde, dann Neuerstellung bei nächsten Durchlauf erzwingen
      if [ ! -f "$pdf_dirname/txt_created_by_pdftotext" ]; then
        logInfo "Schreibe \"$pdf_filename.md5\"."
        echo "$md5_new_Pdf" > "$pdf_dirname/$pdf_filename.md5"
      fi
    fi

    if  [ "$1" == "run" ]; then
      # time_complete_a=$(($(date +%s%N)/1000000))
      if [ -f "$pattern_path" ]; then
        runSearch "$pattern_path" "$pdf_path"
      else
        
        cfg_pattern_files=$(look pattern_files "$script_path"/main.cfg | cut -d '=' -f 2-)
        script_path_escaped=${script_path////\\/}
        cfg_pattern_files=$(sed -e 's/[[:space:]]//g' <<< "$cfg_pattern_files" | sed -e "s/,/\\n/g" | sed -e "s/^/$script_path_escaped\/pattern\//g")

        find "$pattern_path" -type f -name 'test-*.pattern' | { while read -r pattern_case;
          do
            if [[ -d $cfg_pattern_files ]] || [[ $cfg_pattern_files =~ $pattern_case ]]; then
              runSearch "$pattern_case" "$pdf_path"
            fi
        done }
      fi
      # time_complete_b=$(($(date +%s%N)/1000000))
      # logInfo "Gesamtzeit: $((time_complete_b - time_complete_a)) ms"
    fi
  fi
fi

exit 0
