#!/bin/bash

# Trap the INT signal (ctrl-c, for example)
trap trapint 2

red="\e[0;31m"
green="\e[0;32m"
yellow="\e[0;33m"
TOA="\e[0m" # No Color

# Absolute path to this script, e.g. /home/user/bin/foo.sh
script=$(readlink -f "$0")
# Absolute path this script is in, thus /home/user/bin
script_path=$(dirname "$script")

# START functions ##############################################################

function logInfo () {
    echo -e "${green}$1${TOA}" 1>&2
}

function logWarn () {
  echo -e "${yellow}$1${TOA}" 1>&2
}

function logError () {
  echo -e "${red}$1${TOA}" 1>&2
}

function trapint {
  echo
  echo
  echo "$(basename "$0") SIGINT received"
  cleanup
}

function cleanup {
  echo "Cleaning up…"
  rm "$HOME/running/$script_name.pid"
  echo "Bye."
  echo
}

function save_pid {
  script_name=$(basename "$0")
  if [ ! -d "$HOME/running/" ]; then
    mkdir "$HOME/running/"
  fi
  
  if [ -f "$HOME/running/$script_name.pid" ]; then
    echo "$script_name is already running ($HOME/running/$script_name.pid)"
    exit 1
  else
    echo $$ > "$HOME/running/$script_name.pid"
  fi
}

save_pid

# notify-send "$(basename "$0")" "start"

if [ -f "$1" ]; then
  search_root=$(dirname "$1")
else
  search_root="$1"
fi

search_root=$(pwd "$search_root")

logInfo "Suche Calibre-DB (metadata.db)…"

calibreDbSearchPath="$search_root"
while [ ! -f "$calibreDbSearchPath/metadata.db" ] && [ "$calibreDbSearchPath" != "/" ]; do
  logInfo "$calibreDbSearchPath"
  calibreDbSearchPath=$(dirname "$calibreDbSearchPath")
done

if [ -f "$calibreDbSearchPath/metadata.db" ]; then
  logInfo "Calibre-DB (metadata.db) gefunden: \"$calibreDbSearchPath/metadata.db\""
else
  logError "Calibre-DB (metadata.db) nicht gefunden"
  cleanup
  exit 1
fi

find "$search_root" -type f -name '*.pdf' | {
  while read -r pdf_path; do
  working_path=$(dirname "$pdf_path")
  metadata_path="$working_path/metadata.opf"
  if [ ! -f "$metadata_path" ]; then
    echo "$metadata_path not found" 1>&2
  else
    calibre_id=$(xpath -q -e "//package/metadata/dc:identifier[@id='calibre_id']/text()" "$metadata_path")
    
    logInfo "Processing: $working_path"
    
    # pattern_files="$script_path/pattern/*"
    # for pattern_path in $pattern_files; do
    #   keywords=$("$script_path/60road_keywords_from_pdf" run "$pattern_path" "$pdf_path")
    #   keywords=${keywords//Baureihe/BR}
    #   false_positive_pattern_path="$script_path/false_positive/$(basename "$pattern_path")"
    #   if [ -f "$false_positive_pattern_path" ]; then
    #     false_positive_pattern=$(grep "^$calibre_id=" "$false_positive_pattern_path" | gawk  -F "$calibre_id=" '{print $2}')
    #     false_positive_pattern=$(echo "$false_positive_pattern" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
    #     if [ ! -z "$false_positive_pattern" ]; then
    #       keywords=$(echo "$keywords" | sed -e "s/$false_positive_pattern/,/g")
    #       keywords=$(echo "$keywords" | sed -e "s/,,/,/g" | sed -e "s/^,//g" | sed -e "s/,$//g")
    #     fi
    #   fi
    # done
    
    # keywords=$(find "$script_path/pattern" -type f -name '*.pattern' | {
    #   while read -r pattern_path; do
    #     keywords=$("$script_path/60road_keywords_from_pdf" run "$pattern_path" "$pdf_path")
    #     keywords=${keywords//Baureihe/BR}
    #     false_positive_pattern_path="$script_path/false_positive/$(basename "$pattern_path")"
    #     if [ -f "$false_positive_pattern_path" ]; then
    #       false_positive_pattern=$(grep "^$calibre_id=" "$false_positive_pattern_path" | gawk  -F "$calibre_id=" '{print $2}')
    #       if [ ! -z "$false_positive_pattern" ]; then
    #         false_positive_pattern=$(echo "$false_positive_pattern" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
    #         keywords=$(echo "$keywords" | sed -e "s/$false_positive_pattern/,/g")
    #       fi
    #     fi
    #     echo "$keywords"
    #   done
    # })
    
    keywords=$("$script_path/create_railroad_keywords_from_pdf" run "$script_path/pattern" "$pdf_path")
    
    pattern_files="$script_path/pattern/*"
    
    for pattern_path in $pattern_files; do
      false_positive_pattern_path="$script_path/false_positive/$(basename "$pattern_path")"
        if [ -f "$false_positive_pattern_path" ]; then
          false_positive_pattern=$(grep "^$calibre_id=" "$false_positive_pattern_path" | gawk  -F "$calibre_id=" '{print $2}')
          if [ ! -z "$false_positive_pattern" ]; then
            logWarn "Falscher Treffer wird entfernt durch \"$false_positive_pattern\", definiert in \"$false_positive_pattern_path\"."
            false_positive_pattern=$(echo "$false_positive_pattern" | sed -e 's/(/\\(/g' | sed -e 's/)/\\)/g' | sed -e 's/{/\\{/g' | sed -e 's/}/\\}/g' | sed -e 's/|/\\|/g')
            keywords=$(echo "$keywords" | sed -e "s/$false_positive_pattern//g")
            keywords=$(echo "$keywords" | sed -e "s/,,/,/g" | sed -e "s/^,//g" | sed -e "s/,$//g")
          fi
        fi
    done
    
    logInfo "Processing: $pdf_path"
    # keywords=${keywords//Baureihe/BR}
    # keywords=$(echo "$keywords" | sort | sed -e "s/,,/,/g" | sed -e "s/^,//g" | sed -e "s/,$//g" | sed -E 's/(V)[[:space:]]([0-9])/\1\2/g' | sed -E 's/(VT)[[:space:]]([0-9])/\1\2/g' | sed -E 's/(E)[[:space:]]([0-9])/\1\2/g' | sed -E 's/(S)([0-9])/\1 \2/g' | uniq | tr '\n' ',' | sed -e 's/^,//g' | sed -e 's/,$//g' | sed -e 's/,{2,}//' | sed -e 's/ \- /-/g')
    keywords=$(echo "$keywords" | sort | sed -e "s/,,/,/g" | sed -e "s/^,//g" | sed -e "s/,$//g" | uniq | tr '\n' ',' | sed -e 's/^,//g' | sed -e 's/,$//g' | sed -e 's/,{2,}//' | sed -e 's/ \- /-/g')

    old_keywords=$(calibredb show_metadata "$calibre_id"  --library-path="$calibreDbSearchPath" | grep "Tags" | awk -F: '{print $2}' | sed -e 's/^ *//' | sed -e 's/ *$//' | sed -e 's/, /,/g' )
    echo "Tags old: >$old_keywords<"
    echo "Tags new: >$keywords<"
    if [ "$old_keywords" != "$keywords" ]; then
      calibredb set_metadata --field tags:"$keywords" "$calibre_id" --library-path="$calibreDbSearchPath"
    fi
    echo "…done"
  fi
  done
}

echo "…finished"

cleanup

# notify-send "$(basename "$0")" "finished"

exit 0
